---
layout: default
---

# **TLD**

#### &nbsp;&nbsp;&nbsp;&nbsp;这里主要讨论的是文件[1]的TLD跟踪算法。TLD(Tracking-Learning-Detection)是一种针对单一目标的长时间跟踪算法(long-term tracking)。长时间跟踪问题是指：长时间的视频，我们希望对其中某个目标进行跟踪（一个人，一辆车，或者仅仅是一块运动的区域），首先在某一帧画面规定一个矩形框，框住的区域就是我们的目标，跟踪算法需要在视频中不断跟踪这个目标，无论该物体是否暂时离开画面，或者被遮挡，或者发生形变，都不会影响继续的跟踪。要实现这样的长时间跟踪，有一些需要面对的问题。其中最关键的问题是，如果跟踪的目标暂时离开画面，那么当它重新出现的时候该怎么做，还要考虑到尺度、光照变化，复杂背景等。

#### &nbsp;&nbsp;&nbsp;&nbsp;传统的跟踪方法分为模板匹配和检测跟踪方法，模板匹配就是对模板进行特征提取，并在待跟踪的图像提取特征，取匹配程度最高的那块，作为跟踪的结果。而检测跟踪是指首先在目标周围采样正负样本进行分类器的训练，并在跟踪帧在上一帧的目标位置附近用分类器进行分类，寻找正样本的最佳位置，现在检查跟踪方法已经成为了跟踪方法的主流，因其速度快效率高。

#### &nbsp;&nbsp;&nbsp;&nbsp;TLD也是一种检测跟踪方法，分为三个模块：跟踪模块，检测模块，学习模块，每个模块独立运行又互相协作，如下图所示：

<div style="text-align: center">
<img src="../Images/TLD1.png">
</div>

1. <h4>对于跟踪模块，它假设目标在帧与帧之间的运动是连续并且可见的而且两帧之间的运动不能太剧烈，相邻两帧之间的亮度恒定，即光线不会发生大的变化，从而估计出目标在下一帧的位置（这里用到的是光流法）。并将估计到的区域提交给学习模块。</h4>
2. <h4>对于检测模块，其作用是估计跟踪器的误差，如果误差很大就改正跟踪器的结果。检测器对每一帧图像都做全面的扫描( **这也是TLD能够在跟丢之后有很好的重新检测定位的能力** )，找到与目标物体相似的所有外观的位置，从检测产生的结果中产生正样本和负样本，递交给学习模块(Detection->Learning)。算法从所有框中选出一个最可信的位置作为这一帧TLD的输出结果，然后用这个结果更新跟踪器的其实位置(Detection->Tracking)<h4>
3. 对于学习模块，主要是为了更新检测器，使得检测器能够在实时的过程中进行检测。在得到跟踪模块以及检测模块提供的正负样本之后，它要对这两种样本进行一种“取舍”（这里用到的是一种PN-Learning学习方法），再把得到的结果提供给检测模块。跟踪与检测模块提供的样本是可以互相修复互相纠正的，以达到错误率最小的效果。

- ### **主要实施过程：**

#### **1. 初始化**
 
&nbsp;&nbsp;&nbsp;&nbsp;初始化的过程主要是为了初始化训练检测器。检测过程是采用窗口扫描的方式对可能的窗口进行分类。

&nbsp;&nbsp;&nbsp;&nbsp;**采集正样本**： 正样本是采集和目标框最相近的k=10个扫描框。选取方式为，已知了初始化的目标框，首先计算所有的扫描框和目标框的重叠率(两个框的交的面积/两个框的并的面积)，若重叠率>0.6,则认为是和目标框相近的框，再按照重叠率从大到小排列，选取最大的k=10个扫描框作为检测器训练的正样本框，再对每个正样本框进行平移，旋转，缩放等变化各进行20次，这样一共能产生的正样本框为200个。而对已知的目标框中的样本缩放到[15, 15],并拉成列向量，减去向量均值，构成了255X1的特征向量，并计算这一向量的方差作为第一个检测器**Patch variance**的阈值。

&nbsp;&nbsp;&nbsp;&nbsp;**采集负样本**： 首先负样本的框和目标框的重叠率要小(要远离目标框,文中选取的是重叠率<0.2)。在这些选出来的框中再选取样本块的方差大于上面求出的阈值的样本作为全部的负样本(这一步实际上完成了检测器的第一步方差阈值检测)，而选出的负样本是用于第二步Fern检测的训练。

&nbsp;&nbsp;&nbsp;&nbsp;检测器是由3层检测器联合构成的，分别为：

   - patch variance
   &nbsp;&nbsp;&nbsp;&nbsp;这一步主要是通过方差阈值对负样本进行初步筛选，方法阈值为目标框中样本的方差。用这一方差对负样本进行初步筛选，大于阈值的负样本用于下一步的Fern的训练。

   - ensemble classifier
   &nbsp;&nbsp;&nbsp;&nbsp;由多个弱分类器构成，每个分类器有一个Fern构成。假设有nTrees=11棵Fern，每个样本提取的特征维数为nFeat=13维，Fern和Trees不同的是Fern不保存根节点，只保存叶子节点。因此若是每个样本提取的特征维数为13维，则叶子节点应该有$$2^{nFeat}$$。这些个叶子节点称为Fern的后验概率分布$$P_{i}(y|x)$$。在初始化的过程中，这些项的值全部赋值为0。训练Fern的样本的特征提取方法为：首先对样本进行高斯模糊处理，对模糊后的每个样本每棵Fern随机选取13个像素对进行对比，生成nFeat=13维二值序列，将这一二值序列转换成十进制整数，即为本样本在这一棵Fern下的特征。在训练Fern的时候，在训练集上每个叶子节点的后验概率分布$$P_{i}(y|x)=\frac{\# p}{\# p+\# n}$$，其中$$\# p,\# n$$分别表示到达该叶子节点的正样本的个数和负样本的个数(注：这里在处理样本如何到达叶子，一般的Fern都是每个深度分别有一个阈值，用各层的阈值对相应的特征进行大小判断，经过多层分别分类之后到达相应的叶子节点。这里简单为，对叶子节点按顺序编号为$$0-2^{nFeat}$$，将对应的样本由二值序列转化的整数特征置入相应数值的叶子节点上，完成各样本到各叶子节点的分配。)

   - nearest neighbor classifier
   &nbsp;&nbsp;&nbsp;&nbsp;在采集正样本的时候，已经对目标样本进行缩放[15,15]，并减去均值构成列向量特征，这个作为NN训练的正样本。对上面第一步检测器方差筛选出的负样本中随机选取一定数量的负样本(文中选中为100)，也进行相同的缩放并减均值处理提取特征。对这些样本进行分类，分类标准为相似性度量，计算每个样本分别与不断添加的正样本集合和负样本集合(用上述提取的训练NN的样本集)的相似性

$$S(p_{i}, p_{j})=0.5*(NCC(p_{i}, p_{j})+1)$$

&nbsp;&nbsp;&nbsp;&nbsp;这里NNC表示Normalized correlation coefficient，计算方法为;$$\frac{<p_{i}, p_{j}>}{\sqrt{\|p_{i}\|*\|p_{j}\|}}$$。

&nbsp;&nbsp;&nbsp;&nbsp;计算某个样本和正样本集的相似性为：

$$S^{+}(p, M) = max_{p^{+}\in M}S(p,p_{i}^{+})$$

&nbsp;&nbsp;&nbsp;&nbsp;计算某个样本和负样本集的相似性为：

$$S^{-}(p, M) = max_{p^{-}\in M}S(p,p_{i}^{-})$$

&nbsp;&nbsp;&nbsp;&nbsp;计算某个样本的Relative similarity：$$S^{r}=\frac{S^{+}}{S^{+}+S^{-}}$$

&nbsp;&nbsp;&nbsp;&nbsp;若是正样本计算得到的Relative similarity大于某个给定的阈值，则将其分类为正样本，若是负样本得到的Relative similarity小于某个给定的阈值，则将其分类为负样本。**由这一步分类得到的正负样本是用来验证下一步的跟踪得到的目标框的相似性的。**

&nbsp;&nbsp;&nbsp;&nbsp;最后在验证集(由训练样本抽取部分)上更新Fern分类和NN分类的阈值(用验证集上的Relative similarity)。

#### **2. 跟踪**

  &nbsp;&nbsp;&nbsp;&nbsp;<font color="red">跟踪过程是帧帧执行</font>
 
   - 跟踪预测目标框
   - 
#### &nbsp;&nbsp;&nbsp;&nbsp;TLD的跟踪模块使用的算法是基于作者自己提出的Median Flow tracker(中值流跟踪)。跟踪器的FB误差：即从时间t的初始位置x(t)开始追踪产生时间$$t+p$$的位置$$x(t+p)$$,再从位置$$x(t+p)$$反向追踪产生时间$$t$$在这个基础上增加了失败检测。中值流跟踪方法利用目标框(Bounding box)来表示被跟踪的目标，并在连续的相邻视频帧之间估计目标的运动。具体的流程如下：

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1）首先在上一帧的目标框中均匀采样10*10个特征点(网格均匀撒点)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2）利用金字塔LK光流法跟踪这些特征点，并预测当前帧的特征点，计算特征点median误差和median NCC，根据median误差(光流返回的Forward-Backward error)和median NCC(光流返回的)舍弃跟踪不符合的特征点。这里median是指排序之后中间值(奇数个取中间值的数值，偶数个取中间两个数值的平均值)，用这两个median值作为筛选特征点的阈值；

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3）用剩余的特征点来预测目标框bounding box的位置和大小

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4） 跟踪失败检测：如果跟踪的特征点匹配上的个数小于某个阈值，或是bounding box超出画面，则认为跟踪失败，否则跟踪有效.
   

   - 验证预测框的有效性
   
   &nbsp;&nbsp;&nbsp;&nbsp;已经根据跟踪得到的预测目标框，需要验证框的有效性，若是预测框有效(跟踪目标正确)，则后面的learning模块开始学习，否则不进行学习。这里有效性的学习也是利用Relative similarity，提取当前预测框的图像，进行缩放到[15 15]并减去均值提取特征向量，用这一目标特征向量和检测模块NN分类之后得到的正负样本集计算Relative similarity，若是相似性大于某一特定的阈值，则说明跟踪结果是有效的，否则认为跟踪结果无效(跟踪错误了)。

#### **3. 检测**
  &nbsp;&nbsp;&nbsp;&nbsp;<font color="red">检测过程也是帧帧执行。</font>在检测过程中将整个图像中的扫描框分别经过，方差阈值，Fern，NN三层分类器，最后可能会得到多个检测目标框，分别用上述跟踪框相同的方法计算和正负样本的Relative similarity。
 
#### **4. 整合**
 &nbsp;&nbsp;&nbsp;&nbsp;整合的目的是将跟踪得到的预测目标框和检测得到的检测目标框进行合并。

&nbsp;&nbsp;&nbsp;&nbsp;**1)** 若是没有跟踪框，则将检测到的检测框进行合并(合并方法为将多个检测框进行聚类，取Relative similarity最大的类别的平均框作为最终的框)，并重新初始化跟踪框；

&nbsp;&nbsp;&nbsp;&nbsp;**2)** 若是只有跟踪框，没有检测框，则直接将跟踪框最为最终框；

&nbsp;&nbsp;&nbsp;&nbsp;**3)** 若是跟踪框和检测框同时存在，则需要将其合并。求取跟踪框和所有检测框的面积重叠率，重叠率大于一定的阈值(文中则为0.7)则认为为检测框与跟踪框足够相近，取选出的这些检测框和跟踪框的平均框作为最终的输出框。若是所有检测框和跟踪框的面积重叠率不够高，表明跟踪框和检测框两者中有一者是不可信的，这时候比较两者的Relative similarity高的作为最终的输出框。

#### **5. 学习**
&nbsp;&nbsp;&nbsp;&nbsp;这里学习过程是利用的PN-learning，主要是为了在线更新检测器。而是否启动学习是根据跟踪框反馈回来的是否跟踪正确的信息进行判断的。若是跟踪框正确，则需要启动学习框架更新检测器。

&nbsp;&nbsp;&nbsp;&nbsp;PN学习即PN learning, P指代Positive Constraint,也称之为P-expert或者growing event,N指代Negative Constraint,也称之为N-expert或者pruning event。P-expert的作用是发现目标的新的外观(形变)，并以此来增加正样本的数量，从而使得检测模块更具鲁棒性(增加模型的泛化能力)；N-expert的作用是生成负的训练样本(增加模型的判别能力)。N-expert的前提假设是，(被跟踪的)前景目标仅可能出现在视频帧中的一个位置，因此，如果前景目标的位置是确定的，那么其周围必然是负样例。**PN是通过不断的增加的样本对模型进行迭代更新修正，使得模型的判别能力越来越高。**

&nbsp;&nbsp;&nbsp;&nbsp;**1）**采样正样本： 根据跟踪检测之后生成的目标框，生成正样本，生成方法与初始化检测器时的生成方法是一样的(采集和目标框最相近的k=10个扫描框。选取方式为，已知了初始化的目标框，首先计算所有的扫描框和目标框的重叠率**(**两个框的交的面积/两个框的并的面积)，若重叠率>0.6,则认为是和目标框相近的框，再按照重叠率从大到小排列，选取最大的k=10个扫描框作为检测器训练的正样本框，再对每个正样本框进行平移，旋转，缩放等变化各进行10次，这样一共能产生的正样本框为100个。而对已知的目标框中的样本缩放到[15, 15],并拉成列向量，减去向量均值，构成了255X1的特征向量，并计算这一向量的方差作为第一个检测器**Patch variance**的阈值。**)**

&nbsp;&nbsp;&nbsp;&nbsp;**2）**采样负样本：由检测过程中检测为正样本的负样本中和跟踪输出的目标框重叠面积足够小的样本作为负样本。并更新正负训练样本集，执行下一帧的相似性计算。

&nbsp;&nbsp;&nbsp;&nbsp;**3）**利用采样得到的正样本和负样本进行Fern和NN的重新训练。这里需要注意的是是，在更新Fern的样本和NN的负样本不同，更新Fern的负样本是选择与目标框overlap足够小而且在上一次的Fern分类中
计算的置信度Conf足够小的所有样本，而训练NN的样本为上次Fern输出的正样本中重叠面积与目标框足够小的样本(百分比的误检样本)。这样不同是有道理的，Fern的更新应该要用Fern检测的结果进行分析，而不应该用NN输出的结果重新更新，否则经过了NN的二次作用，无法判断Fern还对哪些样本比较不感冒~

#### **Reference**

[1] Zdenek Kalal, **Tracking learning detection**, TPAMI 2010.

[2] <http://johnhany.net/2014/05/tld-the-theory/>

[3] <http://www.thinkface.cn/forum.php?mod=viewthread&tid=3119&extra=page%3D1%26filter%3Dauthor%26orderby%3Ddateline>
